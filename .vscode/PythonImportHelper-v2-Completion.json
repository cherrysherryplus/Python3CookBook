[
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "signature",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 6,
        "importPath": "09 meta programming.0901-decorate-a-function",
        "description": "09 meta programming.0901-decorate-a-function",
        "peekOfCode": "class A:\n    @classmethod\n    def method(cls):\n        pass\nclass B:\n    def method(cls):\n        pass\n    method = classmethod(method)\n# 在上面的 wrapper() 函数中， 装饰器内部定义了一个使用 *args 和 **kwargs 来接受任意参数的函数。\n# 在这个函数里面调用了原始函数并将其结果返回，不过你还可以添加其他额外的代码(比如计时)。",
        "detail": "09 meta programming.0901-decorate-a-function",
        "documentation": {}
    },
    {
        "label": "B",
        "kind": 6,
        "importPath": "09 meta programming.0901-decorate-a-function",
        "description": "09 meta programming.0901-decorate-a-function",
        "peekOfCode": "class B:\n    def method(cls):\n        pass\n    method = classmethod(method)\n# 在上面的 wrapper() 函数中， 装饰器内部定义了一个使用 *args 和 **kwargs 来接受任意参数的函数。\n# 在这个函数里面调用了原始函数并将其结果返回，不过你还可以添加其他额外的代码(比如计时)。\n# 然后这个新的函数包装器被作为结果返回来代替原始函数。\n# 需要强调的是装饰器并不会修改原始函数的参数签名以及返回值。 \n# 使用 *args 和 **kwargs 目的就是确保任何参数都能适用。 \n# 而返回结果值基本都是调用原始函数 func(*args, **kwargs) 的返回结果，其中func就是原始函数。",
        "detail": "09 meta programming.0901-decorate-a-function",
        "documentation": {}
    },
    {
        "label": "timethis",
        "kind": 2,
        "importPath": "09 meta programming.0901-decorate-a-function",
        "description": "09 meta programming.0901-decorate-a-function",
        "peekOfCode": "def timethis(func):\n    '''\n    Decorator that reports the execution time.\n    '''\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(func.__name__, end-start)",
        "detail": "09 meta programming.0901-decorate-a-function",
        "documentation": {}
    },
    {
        "label": "countdown",
        "kind": 2,
        "importPath": "09 meta programming.0901-decorate-a-function",
        "description": "09 meta programming.0901-decorate-a-function",
        "peekOfCode": "def countdown(n):\n    while n>0:\n        n-=1\n# countdown 9.5367431640625e-07\ncountdown(10)\n# 一个装饰器就是一个函数，它接受一个函数作为参数并返回一个新的函数。\n# 上述countdown的定义等价于：\ndef countdown2(n):\n    pass\ncountdown2 = timethis(countdown2)",
        "detail": "09 meta programming.0901-decorate-a-function",
        "documentation": {}
    },
    {
        "label": "countdown2",
        "kind": 2,
        "importPath": "09 meta programming.0901-decorate-a-function",
        "description": "09 meta programming.0901-decorate-a-function",
        "peekOfCode": "def countdown2(n):\n    pass\ncountdown2 = timethis(countdown2)\n# countdown2 7.152557373046875e-07\ncountdown2(10)\n# 内置的装饰器比如 @staticmethod, @classmethod,@property 原理也是一样的。 \n# 例如，下面这两个代码片段是等价的：\nclass A:\n    @classmethod\n    def method(cls):",
        "detail": "09 meta programming.0901-decorate-a-function",
        "documentation": {}
    },
    {
        "label": "countdown2",
        "kind": 5,
        "importPath": "09 meta programming.0901-decorate-a-function",
        "description": "09 meta programming.0901-decorate-a-function",
        "peekOfCode": "countdown2 = timethis(countdown2)\n# countdown2 7.152557373046875e-07\ncountdown2(10)\n# 内置的装饰器比如 @staticmethod, @classmethod,@property 原理也是一样的。 \n# 例如，下面这两个代码片段是等价的：\nclass A:\n    @classmethod\n    def method(cls):\n        pass\nclass B:",
        "detail": "09 meta programming.0901-decorate-a-function",
        "documentation": {}
    },
    {
        "label": "timeit_nowraps",
        "kind": 2,
        "importPath": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "description": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "peekOfCode": "def timeit_nowraps(func):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        res = func(*args, **kwargs)\n        print(func.__name__, time.time()-start)\n        return res\n    return wrapper\n@ timeit_nowraps\ndef countdown(n):\n    '''",
        "detail": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "documentation": {}
    },
    {
        "label": "countdown",
        "kind": 2,
        "importPath": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "description": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "peekOfCode": "def countdown(n):\n    '''\n    docstring\n    '''\n    while n>0:\n        n-=1\n# 使用这个被包装后的函数并检查它的元信息：\n# wrapper\n# None\n# {}",
        "detail": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "documentation": {}
    },
    {
        "label": "timeit",
        "kind": 2,
        "importPath": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "description": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "peekOfCode": "def timeit(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        res = func(*args, **kwargs)\n        print(func.__name__, time.time()-start)\n        return res\n    return wrapper\n@timeit\ndef countdown2(n:int):",
        "detail": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "documentation": {}
    },
    {
        "label": "countdown2",
        "kind": 2,
        "importPath": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "description": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "peekOfCode": "def countdown2(n:int):\n    '''docstring'''\n    while n>0:\n        n-=1\n# 使用这个被包装后的函数并检查它的元信息：\n# countdown2\n# docstring\n# {'n': <class 'int'>}\nprint(countdown2.__name__)\nprint(countdown2.__doc__)",
        "detail": "09 meta programming.0902-reserve-meta-info-when-using-decorator",
        "documentation": {}
    },
    {
        "label": "somedecorator",
        "kind": 2,
        "importPath": "09 meta programming.0903-remove-a-decoration",
        "description": "09 meta programming.0903-remove-a-decoration",
        "peekOfCode": "def somedecorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print('Decoration')\n        res = func(*args, **kwargs)\n        return res\n    return wrapper\n@somedecorator\ndef add(x,y):\n    return x+y",
        "detail": "09 meta programming.0903-remove-a-decoration",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "09 meta programming.0903-remove-a-decoration",
        "description": "09 meta programming.0903-remove-a-decoration",
        "peekOfCode": "def add(x,y):\n    return x+y\n# 解决方案\n# 假设装饰器是通过 @wraps来实现的，那么你可以通过访问 __wrapped__ 属性来访问原始函数：\norig_add = add.__wrapped__\nprint(orig_add(1,2))\nprint('-'*30)\nprint(add(1,2))\n# 讨论\n# 直接访问未包装的原始函数在调试、内省和其他函数操作时是很有用的。 ",
        "detail": "09 meta programming.0903-remove-a-decoration",
        "documentation": {}
    },
    {
        "label": "decorator1",
        "kind": 2,
        "importPath": "09 meta programming.0903-remove-a-decoration",
        "description": "09 meta programming.0903-remove-a-decoration",
        "peekOfCode": "def decorator1(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print('Decorator 1')\n        return func(*args, **kwargs)\n    return wrapper\ndef decorator2(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print('Decorator 2')",
        "detail": "09 meta programming.0903-remove-a-decoration",
        "documentation": {}
    },
    {
        "label": "decorator2",
        "kind": 2,
        "importPath": "09 meta programming.0903-remove-a-decoration",
        "description": "09 meta programming.0903-remove-a-decoration",
        "peekOfCode": "def decorator2(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print('Decorator 2')\n        return func(*args, **kwargs)\n    return wrapper\n@decorator1\n@decorator2\ndef sub(x, y):\n    return x - y",
        "detail": "09 meta programming.0903-remove-a-decoration",
        "documentation": {}
    },
    {
        "label": "sub",
        "kind": 2,
        "importPath": "09 meta programming.0903-remove-a-decoration",
        "description": "09 meta programming.0903-remove-a-decoration",
        "peekOfCode": "def sub(x, y):\n    return x - y\nprint(sub(3,2))\nprint('-'*30)\nprint(sub.__wrapped__(3,2))\nprint('-'*30)\nprint(sub.__wrapped__.__wrapped__(3,2))\n# 最后要说的是，并不是所有的装饰器都使用了 @wraps ，因此这里的方案并不全部适用。 \n# 特别的，内置的装饰器 @staticmethod 和 @classmethod 就没有遵循这个约定 \n# (它们把原始函数存储在属性 __func__ 中)",
        "detail": "09 meta programming.0903-remove-a-decoration",
        "documentation": {}
    },
    {
        "label": "orig_add",
        "kind": 5,
        "importPath": "09 meta programming.0903-remove-a-decoration",
        "description": "09 meta programming.0903-remove-a-decoration",
        "peekOfCode": "orig_add = add.__wrapped__\nprint(orig_add(1,2))\nprint('-'*30)\nprint(add(1,2))\n# 讨论\n# 直接访问未包装的原始函数在调试、内省和其他函数操作时是很有用的。 \n# 但是我们这里的方案仅仅适用于在包装器中正确使用了 @wraps \n# 或者直接设置了 __wrapped__ 属性的情况。\n# 如果有多个包装器，那么访问 __wrapped__ 属性的行为是不可预知的，应该避免这样做。 \n# 在Python3.3中，它会略过所有的包装层；在3.4以上的版本中，会略过最外层的装饰器",
        "detail": "09 meta programming.0903-remove-a-decoration",
        "documentation": {}
    },
    {
        "label": "logged",
        "kind": 2,
        "importPath": "09 meta programming.0904-decorator_with_params",
        "description": "09 meta programming.0904-decorator_with_params",
        "peekOfCode": "def logged(level, name=None, message=None):\n    \"\"\"\n    Add logging to a function. level is the logging\n    level, name is the logger name, and message is the\n    log message. If name and message aren't specified,\n    they default to the function's module and name.\n    \"\"\"\n    def decorate(func):\n        logname=name if name else func.__module__\n        log = logging.getLogger(logname)",
        "detail": "09 meta programming.0904-decorator_with_params",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "09 meta programming.0904-decorator_with_params",
        "description": "09 meta programming.0904-decorator_with_params",
        "peekOfCode": "def add(x, y):\n    return x + y\n@logged(logging.CRITICAL, 'example')\ndef spam():\n    print('Spam!')\nadd(1,3)\nspam()\n# 初看起来，这种实现看上去很复杂，但是核心思想很简单。 \n# 最外层的函数 logged() 接受参数并将它们作用在内部的装饰器函数上面。\n# 内层的函数 decorate() 接受一个函数作为参数，然后在函数上面放置一个包装器。 ",
        "detail": "09 meta programming.0904-decorator_with_params",
        "documentation": {}
    },
    {
        "label": "spam",
        "kind": 2,
        "importPath": "09 meta programming.0904-decorator_with_params",
        "description": "09 meta programming.0904-decorator_with_params",
        "peekOfCode": "def spam():\n    print('Spam!')\nadd(1,3)\nspam()\n# 初看起来，这种实现看上去很复杂，但是核心思想很简单。 \n# 最外层的函数 logged() 接受参数并将它们作用在内部的装饰器函数上面。\n# 内层的函数 decorate() 接受一个函数作为参数，然后在函数上面放置一个包装器。 \n# 这里的关键点是包装器是可以使用传递给 logged() 的参数的。\n# 定义一个接受参数的包装器看上去比较复杂主要是因为底层的调用序列。\n# 上述spam或add的调用序列如下",
        "detail": "09 meta programming.0904-decorator_with_params",
        "documentation": {}
    },
    {
        "label": "spam2",
        "kind": 2,
        "importPath": "09 meta programming.0904-decorator_with_params",
        "description": "09 meta programming.0904-decorator_with_params",
        "peekOfCode": "def spam2():\n    print(\"Spam2!\")\nspam2=logged(logging.DEBUG, name='example', message=\"SPAM2\")(spam2)\nspam2()\n# logged(xx,xx,xx)返回的必须要是一个可调用对象，它接受一个函数作为参数并报装它，\n# 可以参考9.7小节中另外一个可接受参数的包装器例子。",
        "detail": "09 meta programming.0904-decorator_with_params",
        "documentation": {}
    }
]